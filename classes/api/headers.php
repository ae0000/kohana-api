<?php defined('SYSPATH') or die('No direct script access.');
/**
 * API Header manager to first process incoming headers, then generate outgoing
 * headers used to determine the outgoing payload.
 *
 * @Gary Stidston-Broadbent <kohana_api@stroppytux.net>
 * @package API
 * @copyright (c) 2010 Unmagnify team
 * @license http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
 * @version $id$
 * @link http://www.stroppytux.net/projects/kohana_api/
 * @since Available since Release 1.0
 */
class Api_Headers
{
	private $core;

	/* Details of the clients POST data */
	public $input_md5;
	public $input_type;
	public $input_format;
	public $input_length;
	public $input_charset;
	public $input_language;

	/* Details of what the client expects back */
	public $output_type;
	public $output_encoding;
	public $output_language;

	/**
	 * Load the memory pointer into the instance core variable, then process any
	 * headers we received from the client. These will determine how the payload
	 * will be processed and validate the payload we received.
	 *
	 * @access	public
	 * @param	object	$core	Api_Core object
	 * @return	void
	 */
	public function __construct($core)
	{
		$this->core = $core;
	}

	/**
	 * Process the input Content-Type header sent by the client and split all the
	 * data into usable values. The type referes to the process type, eg. text,
	 * application, test. The charset the the character set the payload data was
	 * generated in and the format is the payload format. eg. x-www-urlencoded,
	 * json, xml.
	 *
	 * @access	public
	 * @return	void
	 */
	public function get_input_type()
	{
		/* If the Content-Type has been set, process it and store the values */
		if (array_key_exists('CONTENT_TYPE', $_SERVER)) {
			$content = $this->split_content($_SERVER['CONTENT_TYPE']);

			/* Store the values we extracted */
			if (array_key_exists('type',$content)) {
				$this->input_type = $content['type'];
			}
			if (array_key_exists('charset',$content)) {
				$this->input_charset = $content['charset'];
			}
			if (array_key_exists('format',$content)) {
				$this->input_format = $content['format'];
			}

			/* Overwrite Content-Type format to call the form parser */
			if ($this->input_format == 'x-www-form-urlencoded') {
				$this->input_format = 'form';
			}
		} else {
			/* Store defaults as no Content-Type was set */
			$this->input_type		= NULL;
			$this->input_charset	= 'utf-8';
			$this->input_format		= NULL;
		}
	}

	/**
	 * Store the Content-MD5 header sent by the client for later use to validate
	 * the input payload.
	 *
	 * @access	public
	 * @return	void
	 */
	public function get_input_md5()
	{
		if (array_key_exists('HTTP_CONTENT_MD5', $_SERVER)) {
			$this->input_md5 = $_SERVER['HTTP_CONTENT_MD5'];
		} else {
			$this->input_md5 = NULL;
		}
	}

	/**
	 * Store the Content-Length header sent by the client for later use to
	 * ensure we received the full payload.
	 *
	 * @access	public
	 * @return	void
	 */
	public function get_input_length()
	{
		if (array_key_exists('CONTENT_LENGTH', $_SERVER)) {
			$this->input_length = $_SERVER['CONTENT_LENGTH'];
		} else {
			$this->input_length = NULL;
		}
	}

	/**
	 * Store the Content-Language header sent by the client if they sent on. If
	 * we have a Content-Language header, set the language defined within it,
	 * else set the language to the one set in the api config file.
	 *
	 * @access	public
	 * @return	void
	 */
	public function get_input_language()
	{
		/* If the client set an input language, use it, else use the default */
		if (array_key_exists('CONTENT_LANGUAGE', $_SERVER)) {
			$this->input_language = $_SERVER['CONTENT_LANGUAGE'];
		} else {
			$this->input_language = Kohana::config('api.parser.language');
		}

		/* Set the language fr processing the data and return */
		I18n::lang($this->input_language);
	}

	/* Process the Accept header if the client sent it */
	public function get_output_type()
	{
		/* For now, call the request objects version */
		$this->output_type = Request::accept_type();
	}

	/* Process the Accept-Encoding header if the client sent it */
	public function get_output_encoding()
	{
		/* For now, call the request objects version */
		$this->output_encoding = Request::accept_encoding();
	}

	/* Process the Accept-Language header if the client sent it */
	public function get_output_language()
	{
		/* For now, call the request objects version */
		$this->output_language = Request::accept_lang();
	}

	/**
	 * Set the md5hash on the outgoing payload. We get the hash by hashing the
	 * request response which is generated by the Api_Payload::set_output method.
	 *
	 * @access	public
	 * @return	void
	 */
	public function set_output_md5()
	{
		/* Create a hash of the response, then set the header to the hash */
		$md5hash = hash('md5', $this->core->request->response);
		$this->core->request->headers['Content-MD5'] = $md5hash;
	}

	/**
	 * Set the Content-Type on the outgoing payload. In order to do this, start
	 * by checking the Accept-Type header results to see if we have any generator
	 * that can be accepted. If no Accept-Type header was sent, try to guess the
	 * content type by seeing what type of content they sent us. If we still cant
	 * decide, we set the Content-Type to the default defined in the config file.
	 *
	 * @access	public
	 * @return	void
	 */
	public function set_output_type()
	{
		/* Create some lists for needle finding */
		$input_type		= $this->core->parser->format;
		$creators		= Api_Utils::get_creators();
		$acceptable		= array_keys($this->output_type);

		/* Convert a Content-Type header into a format */
		array_walk($acceptable, "Api_Headers::split_content_array", 'format');
		$usable = array_values(array_intersect($creators, $acceptable));

		/* If client entered 1 or more Content-Types, use them */
		if (count($acceptable) > 1) {
			/* If the client set Content-Types we cant use, return an error */
			if (count($usable) < 1) {
				throw new Api_Exception('Unable to create Accepted type', 406);
			}

			/* If client entered 2+ Content-Types, choose highest q-value */
			if (count($usable) > 1) {
				$max = 0;
				foreach ($usable as $use) {
					if ($this->output_type['application/'.$use] > $max) {
						$max = $this->output_type['application/'.$use];
						$type = 'application/'.$use;
						$this->core->request->headers['Content-Type'] = $type;
					}
				}

			/* Client entered 1 Content-Type, use it */
			} else {
				$type = 'application/'.$usable[0];
				$this->core->request->headers['Content-Type'] = $type;
				return;
			}

		/* The user didnt enter a Content-Type, try guess one */
		} else {
			/* If client used input format we have a generator for, use it */
			if (array_search($input_type, $creators) !== false) {
				$type = 'application/'.$input_type;
				$this->core->request->headers['Content-Type'] = $type;
				return;

			/* Couldnt guess Content-Type, use default as client doesnt care */
			} else {
				$type = 'application/'.Kohana::config('api.creator.type');
				$this->core->request->headers['Content-Type'] = $type;
				return true;
			}
		}
	}

	/* FIXME: Need to implement outgoing language settings */
	/* Set the output language. It sets the Content-Language header and payload */
	public function set_output_language()
	{
		/* Check if the client set an Accept-Language */

		/* If no Accept-Language, use the default */
		$this->output_language = Kohana::config('api.creator.language');

		/* Set the Content-Language header and I18n languages */
		$this->core->request->headers['Content-Language'] = $this->output_language;
		I18n::lang($this->output_language);
		return true;
	}

	/**
	 * Given a Content-Type HTTP header, split the value into its respective
	 * parts. This could include and (or non) of the following: type, format,
	 * and character set.
	 *
	 * @access	public
	 * @param	string	String containing the header values.
	 * @param	string	String containing only the value to be returned.
	 * @return	array	Array containing the different parts of the header.
	 * @return	string	String containing a specific value.
	 */
	public static function split_content($content, $value=null)
	{
		/* Break up the Content-Type header to usable chunks */
		$reg  = '/(?P<type>[[:alpha:]*]+\/(?P<format>[[:alpha:]*\-]+));';
		$reg .= '?[[:space:]]*(charset=\"?(?P<charset>[[:alnum:]-]+)\"?)?/';
		preg_match($reg, $content, $result);

		/* If requested, only return a subset of the values */
		if (!is_null($value)) {
			if (array_key_exists($value, $result)) {
				return $result[$value];
			} else {
				return false;
			}
		} else {
			return $result;
		}
	}

	/* Callback wrapper for split_content */
	public function split_content_array(&$content, $key, $value=null)
	{
		/* pass the content value into split_array, then store back */
		$content = Api_Headers::split_content($content, $value);
	}
}
?>
